<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>D3: Force Layout</title>
		<script src="js/jshashtable-3.0.js" charset="utf-8"></script>
		<script src="js/d3.v3.min.js" charset="utf-8"></script>
		<script src="js/Font.js" charset="utf-8"></script>
		<link href='http://fonts.googleapis.com/css?family=Ubuntu' rel='stylesheet' type='text/css'>
		<style type="text/css">

			body {
				font-size: 12px;
				font-family: 'Ubuntu';
			}

			.node {
				stroke: #fff;
				stroke-width: 1.5px;
			}

			.edge {
				stroke: black;
				stroke-width: 2;
			}
		</style>
	</head>
	<body>
		<script type="text/javascript">

			var Point = function( x, y ) {

				this.x = x;
				this.y = y;

			};

			Point.prototype = {

					distSquared : function( p2 ) {

						Δx = p2.x - this.x;
						Δy = p2.y - this.y;

						return ( Δx * Δx ) + ( Δy * Δy )
					}
			};

			var StopWatch = function() {

				this.startTime = null;
				this.stopTime = null;
				this.running = false;
			};

			StopWatch.prototype = {

					getTime : function() {

						var day = new Date();
						return day.getTime();
					},

					start : function() {

						if ( this.running ) {
							return;
						}

						if ( this.startTime != null ) {
							this.stopTime = null;
						}

						this.running = true;
						this.startTime = this.getTime();
					},

					stop : function() {

						if ( this.running == false ) {
							return;
						}

						this.stopTime = this.getTime();
						this.running = false;
					},

					duration : function() {

						if ( this.startTime == null || this.stopTime == null ) {
							return;
						}

						return ( this.stopTime - this.startTime );
					}
			};

			var stopWatch = new StopWatch();
			var nodesTable = new Hashtable();

			var font = new Font();
			font.fontFamily ="Ubuntu";
			font.src = font.fontFamily;

			font.onload = function() {

				d3.selection.prototype.moveToFront = function() {
					return this.each( function(){
						this.parentNode.appendChild(this);
					});
				};

				var width = window.innerWidth,
					height = window.innerHeight;

				var colors = d3.scale.category20();

				var force = d3.layout.force()
					.charge(-300)
					.linkDistance(300)
					.size([width, height]);

				var svg = d3.select("body").append("svg:svg")
					.attr("width", width)
					.attr("height", height);

				function boxLength( node ) {

					return font.measureText(node.localname, 12).width + 50;
				};

				d3.json("data-converted/fitjava-1.1.jar.json", function(dataset) {

					force.nodes(dataset.nodes)
						.links(dataset.edges)
						.start();

					var edges = svg.selectAll(".edge")
						.data(dataset.edges)
						.enter()
						.append("svg:line")
						.attr("class", "edge");

					var nodes = svg.selectAll("g")
						.data(dataset.nodes)
						.enter()
						.append("svg:g")
						.on("mousedown",function(){
							var sel = d3.select(this);
							sel.moveToFront();
						})
						.call(force.drag);

					// Main Box
					nodes.append("svg:rect")
						.attr("class", ".node")
						.attr("width", function(node) {

							return boxLength(node);
						})
						.attr("height", 60)
						.style("fill", "#ffffc7")
						.style("stroke", "#000")
						.style("stroke-width", 1);

					// Line
					nodes.append("svg:line")
						.attr("x1", 0)
						.attr("y1", 25)
						.attr("x2", function(node) {

							return boxLength(node);
						})
						.attr("y2", 25)
						.style("stroke", "#000")
						.style("stroke-width", 1);

					// Text
					nodes.append("svg:text")
						.attr("x", 25)
						.attr("y", 15)
						.attr("class", ".label")
						.text( function(d) {
							return d.localname;
						});
					stopWatch.start();
					force.on("tick", function() {
						edges.attr("x1", function(d) { return d.source.x; })
							.attr("y1", function(d) { return d.source.y; })
							.attr("x2", function(d) { return d.target.x; })
							.attr("y2", function(d) { return d.target.y; });

						nodes.attr("transform", function(d) {

							var next = new Point( d.x - 50, d.y - 30 );

							if ( nodesTable.containsKey( this ) ) {

								var previous = nodesTable.get( this );
								d2 = next.distSquared( previous );

								if ( d2 < 0.00001 ) {
									stopWatch.stop();
									console.log( stopWatch.duration() );
								};
							};

							nodesTable.put( this, next );

							return "translate(" + next.x + "," + next.y + ")";
						});
					});
				});
			};

		</script>
	</body>
</html>
